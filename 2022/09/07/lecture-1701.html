<h1 id="lecture-171">Lecture 17.1</h1>

<h2 id="lecture-171---scaling-up-graph-neural-networks"><strong>**Lecture 17.1 - Scaling up Graph Neural Networks</strong>**</h2>

<p><strong>Graphs in Modern Applications</strong></p>

<p>오늘날 그래프는 어떠한 도메인에서 널리 활용될까요? 예를 들어 살펴보겠습니다.</p>

<ol>
  <li><strong>추천 시스템 (Recommender systems)</strong></li>
</ol>

<p><img src="Lecture%2017%201%20b9a1e619ffe74c69856011b56b56b644/Untitled.png" alt="Untitled" /></p>

<p>아마존, 유튜브, 핀터레스트와 같은 기업들에서는 user-item의 이분 그래프 (bipartite graph)를 활용하여 유저들에게 아이템을 추천하거나 (link prediction), 유저 또는 아이템을 분류하는 (node classification) 서비스를 제공하고 있습니다. 보통 대기업 서비스를 이용하는 유저가 매우 많고 판매하는 아이템 또한 굉장히 다양하기 때문에 활용되는 이분 그래프의 크기는 매우 큽니다.</p>

<ol>
  <li><strong>소셜 네트워크 (Social networks)</strong></li>
</ol>

<p><img src="Lecture%2017%201%20b9a1e619ffe74c69856011b56b56b644/Untitled%201.png" alt="Untitled" /></p>

<p>페이스북, 트위터, 인스타그램과 같은 기업들에서는 사용자 그래프를 활용하여 친구를 추천하거나 (link-level), 성별과 같은 사용자의 특징을 파악하는 (nodel-level) 서비스를 제공하고 있습니다. 대형 SNS를 활용하는 사용자가 매우 많기 때문에 해당 기업들이 다루어야 하는 그래프의 크기 또한 매우 큽니다.</p>

<ol>
  <li><strong>학술 그래프 (Academic graph)</strong></li>
</ol>

<p><img src="Lecture%2017%201%20b9a1e619ffe74c69856011b56b56b644/Untitled%202.png" alt="Untitled" /></p>

<p>마이크로소프트 학술 그래프는 약 120M 편의 논문과 120M 명의 저자로 구성되어 있는 매우 큰 그래프로써, 이를 활용하여 논문 분류 (node classification), 협력 연구자 추천 및 논문 인용 추천 (link prediction) 등과 같은 서비스를 제공합니다.</p>

<ol>
  <li><strong>지식 그래프 (Knowledge Graphs (KGs))</strong></li>
</ol>

<p><img src="Lecture%2017%201%20b9a1e619ffe74c69856011b56b56b644/Untitled%203.png" alt="Untitled" /></p>

<p>위키피디아, 프리베이스 등에서 제공하는 지식 그래프를 활용하여 KG completion이나 reasoning과 같은 머신러닝 태스크를 수행합니다. 이 때, 지식 그래프에 포함된 entity의 갯수는 약 80M-90M로 또한 매우 큰 그래프를 다루게 됩니다.</p>

<p><strong>What is in Common?</strong></p>

<p>앞서 설명하였듯이 그래프는 다양한 도메인에서 널리 활용되고 있습니다. 여기서, 도메인에 무관하게 활용되는 그래프는 아래와 같은 공통점을 갖습니다.</p>

<ul>
  <li><strong>매우 큰 스케일</strong>
    <ul>
      <li><strong>노드의 수는 대략 10M ~ 10B 입니다.</strong></li>
      <li><strong>엣지의 수는 대략 100M ~ 100B 입니다.</strong></li>
    </ul>
  </li>
  <li><strong>풀고자 하는 태스크</strong>
    <ul>
      <li>Node-level : 유저/아이템/논문 분류</li>
      <li>Edge-level : 추천, completion</li>
    </ul>
  </li>
</ul>

<p>우리는 오늘 포스트에서 이러한 <strong>큰 그래프에 적용할 수 있도록 GNN을 scalable하게 만드는 방법들</strong>에 대해서 배워보겠습니다!</p>

<p><strong>Why is it Hard?</strong></p>

<p>일반적으로 우리는 머신러닝 모델을 학습하기 위해서 전체 데이터 포인트에 대한 loss 함수를 최소화하는 방향으로 파라미터를 업데이트 해 나갑니다. 만약 데이터셋에 총 $N$개의 데이터 포인트가 있다면 수식은 아래와 같습니다.</p>

<p><img src="Lecture%2017%201%20b9a1e619ffe74c69856011b56b56b644/Untitled%204.png" alt="Untitled" /></p>

<p>하지만 만약 $N$이 굉장히 크다면, 모든 데이터 포인트에 대해 loss 값을 계산하는 데 시간이 너무 많이 들기 때문에 우리는 <strong>full-batch training 대신 mini-batch를 활용하는 Stochastic Gradient Descent (SGD)를 수행하게 됩니다.</strong> 6강에서 SGD를 자세히 설명하였으니 자세한 설명은 넘어가도록 하겠습니다. 간략하게 말해서, $M(«N)$ 개의 데이터 포인트를 반복적으로 랜덤하게 샘플링하여 추출된 mini-batch에 대해서 gradient descent를 각각 수행하는 방법입니다. SGD는 full-batch training에 비해 빠르게 수렴하며, 계산상의 효율성을 가집니다.</p>

<ol>
  <li>그렇다면 효율적인 <strong>SGD를 GNN에 적용</strong>해볼까요?</li>
</ol>

<p><img src="Lecture%2017%201%20b9a1e619ffe74c69856011b56b56b644/Untitled%205.png" alt="Untitled" /></p>

<p>Mini-batch를 구성할 때, $M$개의 노드가 랜덤하게 샘플링되기 때문에 위 그림과 같이 각 샘플링된 노드들은 서로 연결되지 않고 고립되어 있을 가능성이 큽니다. GNN이 이웃 노드의 feature을 aggregate하여 타겟 노드의 feature을 업데이트 한다는 것을 생각한다면 고립된 노드로는 올바르게 노드 feature을 업데이트 할 수 없게 됩니다. <strong>따라서 SGD를 단순히 GNN에 적용하는 것은 좋은 생각이 아닙니다.</strong></p>

<ol>
  <li>그렇다면 그냥 <strong>full-batch training 방식으로 GNN을 학습</strong>시켜 볼까요?</li>
</ol>

<p><img src="Lecture%2017%201%20b9a1e619ffe74c69856011b56b56b644/Untitled%206.png" alt="Untitled" /></p>

<p>Full-batch training 방식으로 GNN을 학습시키려면, 먼저 전체 그래프와 초기 노드 feature를 로드한 후, 매 GNN layer 마다 이전 layer에서 얻은 노드 임베딩을 활용하여 전체 노드 임베딩을 한꺼번에 업데이트 해야 합니다. 따라서, 매 GNN layer 마다의 전체 노드 임베딩을 모두 GPU 메모리에 올려야 위와 같은 계산이 가능하게 됩니다. 하지만 GPU는 빠른 연산 속도를 갖는 반면 수용할 수 있는 메모리의 양이 10GB ~ 20GB으로 굉장히 작기 때문에 <strong>full-batch training으로 GNN을 학습할 수 없습니다.</strong></p>

<p>SGD도 안된다, full-batch training 학습 방식도 안된다. 그럼 대체 큰 그래프를 어떻게 GNN으로 학습할 수 있을까요? 오늘 포스트에서 이를 다뤄보겠습니다.</p>

<p><strong>Today’s Lecture</strong></p>

<p>오늘 다룰 내용을 간단하게 요약하자면, <strong>GNN을 scalable하게 만드는 세 가지 방법</strong>을 차례로 소개할 것입니다.</p>

<ul>
  <li><strong>Mini-batch를 작은 subgraph로 두고 message passing을 수행하는 방법</strong>
    <ul>
      <li><strong>Neighbor Sampling</strong> [Hamilton et al. NeurIPS 2017]</li>
      <li><strong>Cluster-GCN</strong> [Chiang et al. KDD 2019]</li>
    </ul>

    <p>→ 매번 mini-batch로 샘플링된 subgraph만 GPU에 올려서 loss를 계산해주면 됩니다.</p>

    <p><strong>→ 일반적인 GNN 구조 그대로 사용 &amp; Mini-batch를 만드는 다양한 방식 &amp; SGD training</strong></p>
  </li>
  <li><strong>GNN 구조 자체를 단순화 시키는 방법</strong>
    <ul>
      <li><strong>Simplified GCN</strong> [Wu et al. ICML 2019]</li>
    </ul>

    <p>→ 그냥 CPU만 써서도 효율적으로 계산할 수 있습니다.</p>

    <p><strong>→ GNN 구조를 변경 &amp; Mini-batch는 원래대로 랜덤하게 추출 &amp; SGD training</strong></p>
  </li>
</ul>

<hr />
