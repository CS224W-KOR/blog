<h1 id="lecture-132">Lecture 13.2</h1>

<h2 id="lecture-132---network-communities"><strong>**Lecture 13.2 - Network Communities</strong>**</h2>

<p>13.1 파트를 통해 우리는 네트워크에 서로 밀집되어 연결된 노드 커뮤니티가 존재한다는 사실을 알게 되었습니다. 그렇다면 그래프가 주어졌을 때, 이런 노드 커뮤니티를 어떻게 자동으로 찾을 수 있을까요?</p>

<p><img src="Lecture%2013%202%20833d11c046a64e2bb9a282d973b05e64/Untitled.png" alt="Untitled" /></p>

<aside>
💡 **How do we automatically find such densely connected groups of nodes?**

</aside>

<p><strong>Examples of Network Communities</strong></p>

<ol>
  <li>
    <p>Zachary’s Karate Club Network</p>

    <p><img src="Lecture%2013%202%20833d11c046a64e2bb9a282d973b05e64/Untitled%201.png" alt="Untitled" /></p>

    <p>GNN을 다뤄보신 분이라면 익숙할 Zachary’s Karate Club 네트워크에도 국소적인 고밀집 커뮤니티가 존재합니다. Zachary가 대학 내 태권도 동아리의 부원들을 대상으로 데이터를 수집하던 당시, 부원 사이에 갈등이 생겨 자연스레 두 무리로 나뉘었다고 합니다. 친구들이 다퉈서 무리가 나뉘는 경우를 생각해보면, 자연스럽게 그 중 더 끈끈한 친구들끼리 각 무리를 형성하게 됩니다. 이러한 현상이 뚜렷하게 나타난 위 그래프에서도 커뮤니티 분리는 <strong>엣지를 최소한으로 자르는 형태</strong>로 일어납니다.</p>
  </li>
  <li>
    <p>Micro-Markets in Sponsored Search</p>

    <p><img src="Lecture%2013%202%20833d11c046a64e2bb9a282d973b05e64/Untitled%202.png" alt="Untitled" /></p>

    <p><strong>Query-to-Advertiser 그래프를 분할함으로써</strong> 국소 마켓(커뮤니티)들을 찾을 수 있습니다. 위 그림에 표시된 파란색 박스는 gambling에 관심이 있는 인터넷 사용자들에게 광고하길 원하는 advertiser의 커뮤니티라고 볼 수 있겠군요.</p>
  </li>
  <li>
    <p>NCAA Football Network</p>
  </li>
</ol>

<p><img src="Lecture%2013%202%20833d11c046a64e2bb9a282d973b05e64/Untitled%203.png" alt="Untitled" /></p>

<p><img src="Lecture%2013%202%20833d11c046a64e2bb9a282d973b05e64/Untitled%204.png" alt="Untitled" /></p>

<p>위의 왼쪽 그래프는 미식축구 팀들과 팀 사이 경기를 나타낸 그래프입니다. 뚜렷한 고밀집 부위를 육안으로 판단하기 힘든 왼쪽 그래프에서도 노드 커뮤니티를 찾을 수 있을까요? 네, 가능합니다 😊 <strong>NCAA(전미 대학 체육 협회)의 division에 따라</strong> 그래프를 좀 정리해본다면 동일 division에 속한 팀들끼리 크게 밀집되어 있음을 쉽게 확인할 수 있습니다!</p>

<p><strong>Modularity-based Community Detection: Concept Overview</strong></p>

<p>하지만 앞에서 살펴본 커뮤니티 split 방법들은 너무 domain-specific하고 일반화하기 어렵습니다. 따라서 우리는 그래프가 주어졌을 때 자동으로 커뮤니티를 탐지하고 분리하는 방법을 알아보겠습니다.</p>

<p>들어가기에 앞서 <strong>Modularity</strong>라는 새로운 metric을 정의하고 가겠습니다.</p>

<blockquote>
  <p><strong>Modularity Q</strong>
<strong>네트워크가 커뮤니티로 얼마나 잘 분리되었는지 판단하는 측정치</strong>
<em>(cf. 커뮤니티: 밀도 높게 연결된 노드의 집합을 의미함)</em></p>

</blockquote>

<p>우리가 주어진 네트워크를 서로 나뉜 subgraph $s$의 집합 $S$로 분리했다고 가정해봅시다($s \in S$). 그렇다면 우리는 modularity를 구함으로써 우리가 주어진 그래프를 얼마나 잘 분리했는지 정량적으로 측정할 수 있습니다. Modularity Q를 구하는 식은 아래와 같습니다.</p>

<p><img src="Lecture%2013%202%20833d11c046a64e2bb9a282d973b05e64/Untitled%205.png" alt="Untitled" /></p>

<p>식을 그대로 해석해보자면 modularity는 각각의 subgraph $s$에 대해 subgraph 내부에 실제로 존재하는 엣지 수와 null model을 통해 예측된 엣지 수의 차이를 구한 후, $S$ 내의 모든 subgraph에 대해 이 값을 총합함으로써 구할 수 있습니다. 만약 우리가 네트워크를 기가 막히게 커뮤니티 별로 분리해냈다면, 분리된 subgraph $s$는 tightly-connected, 즉 내부 엣지의 수가 많을 것이기 때문에 modularity가 커질 것입니다. 따라서 커뮤니티를 잘 찾아낸다는 것은 곧 modularity가 크다는 의미이고, 그렇기 때문에 우리는 <strong>modularity를 최대화하는 방향으로 커뮤니티 분리를 진행할 것</strong>입니다.</p>

<p><strong>Null Model: Configuration Model</strong></p>

<p>여기서 잠깐! Modularity를 정의할 때 subgraph $s$내에 몇 개의 엣지가 존재할 지 예측하는 부분에서 null model을 활용해야 한다고 했는데요. 여기서 나온 null model은 사실 지난 12강 subgraph mining 강의에서 다뤘던 내용이지만 이해를 위해 여기서도 간략히 설명하고 넘어가도록 하겠습니다.</p>

<p>Null model은 $n$개의 노드를 가지고, $m$개의 엣지로 이루어진 그래프 $G$를 노드 단위로 다 자르고 엣지 연결을 재배치한 그래프 $G’$를 만듭니다. 이 때 각 노드의 차수를 유지하기 위해 노드의 연결부들은 보존한채로 그래프 $G$를 아래 그림처럼 노드 단위로 분해합니다. 엣지 재배치는 단순하게 하나의 연결부를 여러 가능한 연결부 중 랜덤하게 접합함으로써 이루어집니다. 이 때 계산상의 편의성을 위해 $G’$는 두 노드 사이에 여러 엣지가 존재할 수 있는 multigraph로 간주합니다.</p>

<p><img src="Lecture%2013%202%20833d11c046a64e2bb9a282d973b05e64/Untitled%206.png" alt="Untitled" /></p>

<p>이제 엣지 재배치를 좀 더 심도있게 살펴보겠습니다. 위 그림에서 노드 $i$와 노드$j$사이에 몇 개의 엣지가 생성될지는 $k_i \cdot \frac{k_j}{2m} = \frac{k_ik_j}{2m}$을 통해 구할 수 있습니다. 노드 $i$에서 뻗어 나가는 연결부 $k_i$에 대해서 각 연결부가 노드 $j$로 접합될 확률은 전체 연결부 $2m$개 중에 $k_j$개의 연결부로 도달할 때 뿐이기 때문에 $\frac{k_j}{2m}$으로 나타낼 수 있습니다.</p>

<aside>
💡 **The expected number of edges between nodes $i$ and $j$ of degrees $k_i$ and $k_j$ equals** $\frac{k_ik_j}{2m}$

</aside>

<p>그렇다면 재배치 된 그래프 $G’$ 전체에 대해서 예상되는 엣지의 수는,</p>

<p><img src="Lecture%2013%202%20833d11c046a64e2bb9a282d973b05e64/Untitled%207.png" alt="Untitled" /></p>

<p>다음과 같이 구할 수 있습니다. 여기서 주목할 점은 null model을 사용하여 엣지를 싹 재배치 한다고 하더라도, 전체 노드 차수 분포나 총 엣지 수는 보존 된다는 것입니다.</p>

<p><strong>Modularity-based Community Detection</strong></p>

<p>이제 다시 modularity 설명으로 돌아와서, null model의 수식적 표현을 활용하여 modularity를 다시 표현해보면 아래와 같습니다.</p>

<p><img src="Lecture%2013%202%20833d11c046a64e2bb9a282d973b05e64/Untitled%208.png" alt="Untitled" /></p>

<p>즉, 모든 분리된 subgraph $s$에 대해서 $s$내의 모든 가능한 노드 쌍에 대해 실제 두 노드의 연결 여부($A_{ij}$)와 null model로써 예측된 두 노드 사이의 엣지 갯수($\frac{k_ik_j}{2m}$)의 차이를 총합함으로써 modularity $Q$를 구할 수 있습니다. 여기서 계수 $\frac{1}{2m}$은 단순히 $Q$값을 -1과 1 사이로 만들기 위해 붙었다고 보시면 됩니다.</p>

<p><strong>만약 우리가 밀도 높은 커뮤니티들을 잘 분리해냈다면 modularity $Q$가 양수의 값을 가지게 될 것이고, 이 값이 1에 가까워질 수록 더욱 더 잘 분리했다고 생각할 수 있습니다.</strong> 일반적으로 $Q$가 0.3-0.7 사이의 값을 가질 때 커뮤니티 구조를 잘 파악했다고 본다고 합니다. <strong>따라서 앞으로 다룰 community detection은 모두 이 modularity 값을 최대화 하는 objective을 가지고 이야기가 진행될 것입니다.</strong></p>

<aside>
💡 **Community Detection ↔ Maximizing Modularity**

</aside>

<p>앗! 참고로 지금까지는 unweighted 그래프 기준으로 설명드렸지만, 단순하게 이진 인접행렬을 weighted 인접행렬, 그리고 노드 차수를 weighted 차수(edge weights의 합)로 바꿈으로써 weighted 그래프에도 확장 적용할 수 있습니다 🤭 (unweighted 그래프 = edge weight가 모두 1인 weighted 그래프로 생각할 수 있으므로…)</p>

<hr />
